function [D,M]=vlookup(D,KeyField,RefTbl,RefField,varargin)
% function D=vlookup(D,KeyField,RefTbl,RefField,ReturnField)
%
% This performs an Excel-like table lookup on the contents of one table into
% another table (that's right, I'm using Matlab to craft an unholy blend of SQL
% and MS office).  The function runs through the entries in D.(KeyField), for each
% one locating a match in RefTbl(:).(RefField).  The corresponding entry in
% RefTbl.(ReturnField) is used to populate a new field in D.
%
% function D=vlookup(D,KeyField,RefTbl,RefField,ReturnField,args...)
% can be used to modify the function's behavior.  The following arguments are
% recognized: 
%
%  'inplace' - replace the contents of D.(KeyField) with the returned value,
%  instead of adding it into a new field.
%
%  'inexact' - like excel's not_exact_match arg; if no exact match is found,
%  return the nearest value that is less than the key value.  
%
%  'strdist' - for string KeyField values, return the result with the shortest
%  Levenshtein distance from the key value.
%
%  'oldstrdist' - use naive strdist algorithm
%
% The user must supply only enough of the argument to render it unambiguous
% (currently, 3 characters).
%
% Special invocation:
% function D=vlookup(D,KeyField,'FACILITY',) - use the global
% FACILITY_lookup function to populate ReturnField with the index into the
% current global Facilities database.  If ReturnField is actually 'inplace', 
% .. does it in place.
%
% An optional second argument will return a logical array indicating which entries
% did not match (this will be all 'true' for 'inexact' and 'strdist' lookups).

% first, process varargin
inplace=false;
match='exact';
if isa(RefTbl,'char') & strcmp(RefTbl,'FACILITY')
  match='facility'; 
  if strcmp(ReturnField,'inplace') inplace=1;
  end
end

while ~isempty(varargin)
  if ischar(varargin{1})
    switch varargin{1}(1:3)
      case 'inp'
        inplace=1;
      case 'ine'
        match='inexact';
      case 'str'
        match='strdist';
      case 'old'
        match='oldstrdist';
      otherwise
        ReturnField=varargin{1};
    end
  else
    disp('Don''t understand argument:')
    disp(varargin{1})
    keyboard
  end
  varargin(1)=[];
end



switch class(D(1).(KeyField))
  case 'double'
    KeyData=[D(:).(KeyField)];
    [RefData,I]=sort([RefTbl(:).(RefField)]); % assume RefField is the same class 
    RtnData={RefTbl(I).(ReturnField)};

    result=nan(size(KeyData));

    % now fill in unmatched results if inexact matches are allowed
    switch match
      case 'exact'
        % first find exact matches: rows are RefData; cols are KeyData
        [matches,keys]=find(bsxfun(@eq,RefData(:),KeyData(:)'));
        result(keys)=matches;
      case 'inexact'
        % excel reports the nearest result that is lower than the key
        % RefData is already sorted, so we can use diff
        [matches,keys]=find(diff([bsxfun(@le,RefData(:),KeyData(:)');zeros(size(KeyData(:)'))]));
        result(keys)=matches;
      case 'strdist'
        error('Strdist not applicable to numeric data fields')
    end
    
  case 'char'
    KeyData={D(:).(KeyField)};
    [RefData,I]=sort({RefTbl(:).(RefField)}); % assume RefField is the same class 
    RtnData={RefTbl(I).(ReturnField)};

    result=nan(size(KeyData));


    % unfortunately- no bsxfun for cells
    switch match
      case 'exact'
        celleq=cellfun(@strcmp,KeyData,repmat({RefData'},size(KeyData,1), ...
                                              size(KeyData,2)),'UniformOutput',0);
        [matches,keys]=find([celleq{:}]);
        result(keys)=matches;
        
      case 'inexact'
        warning('Not really inexact match- just for-loop version')
        %error('Not implemented!')
        
        for i=1:length(KeyData)
          result(i)=find(strcmp(KeyData{i},RefData)); % if empty, empty.
        end
        
      case 'strdist'
        disp('Not implemented yet!')
        keyboard
        
      case 'oldstrdist'
        d=strdist(KeyData,RefData); % returns a cell array of RefData-size arrays
        mins=cellfun(@find,cellfun(@eq,d,num2cell(cellfun(@min,d)), ...
                                   'UniformOutput',0),'UniformOutput',0);
        mins(cellfun(@length,mins)==length(RefData))=deal({[]}); % all-min means
                                                                 % no match
        multi=find(cellfun(@length,mins)>1); %multiple results- take the first
        for i=1:length(multi)
          disp(['  ambiguous match on KeyData ' num2str(multi(i))])
          mins{multi(i)}=mins{multi(i)}(1);
        end
        % for all others, take the first match
        keys=~cellfun(@isempty,mins);
        matches=[mins{keys}];
        
        result(keys)=matches;
    
        % now we mess with keys to have M contraindicate ambiguous as well 
        % as un-matching records
        keys(multi)=false;
    end
    
    %     % now fill in unmatched results if inexact matches are allowed
%     switch match
%       case 'exact'
%         % first find exact matches: rows are RefData; cols are KeyData
%         [matches,keys]=find(bsxfun(@eq,RefData(:),KeyData(:)'));
%         result(keys)=matches;
%       case 'inexact'
%         % excel reports the nearest result that is lower than the key
%         % RefData is already sorted, so we can use diff
%         [matches,keys]=find(diff([bsxfun(@le,RefData(:),KeyData(:)');zeros(size(KeyData(:)'))]));
%         result(keys)=matches;
%       case 'strdist'
%         error('Strdist not applicable to numeric data fields')
%     end
    
  otherwise
    disp('Don''t know how to match this:')
    disp(KeyData{1})
end

% now assign the results to the desired field

% if isnumeric(RtnData{1})
%   badresult=NaN;
% else
%   badresult='N/A';
% end

[OutData{~isnan(result)}]=RtnData{result(~isnan(result))};
[OutData(isnan(result))]=KeyData(isnan(result));

if inplace
  [D(:).(KeyField)]=deal(OutData{:});
else
  [D(:).(ReturnField)]=deal(OutData{:});
end

M=logical(zeros(size(D)));
M(keys)=true;
% easy-peasy.
